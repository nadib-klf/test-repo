name: Sync New SQL Files to Another Repository with Versioning

on:
  push:
    branches:
      - main  # Trigger only on changes to the main branch
    paths:
      - 'resources/sql/**'  # Trigger only when changes are made to files in /resources/sql/

jobs:
  sync-sql-files:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout the current repository
      - name: Checkout current repository
        uses: actions/checkout@v3

      # Step 2: Identify the new or modified SQL files
      - name: Find new or modified SQL files
        id: find-sql-files
        run: |
          echo "Checking for new or modified SQL files in /resources/sql/"

          # Check if this is the first commit in the repository
          if git rev-list --count HEAD > /dev/null 2>&1 && [ $(git rev-list --count HEAD) -gt 1 ]; then
            # If there are multiple commits, use HEAD^ to compare with the previous commit
            FILES=$(git diff --name-only HEAD^ HEAD -- 'resources/sql/')
          else
            # If this is the first commit, list all files in /resources/sql/
            FILES=$(git ls-files -- 'resources/sql/')
          fi

          echo "Files changed: ${FILES}"
          echo "::set-output name=files::${FILES}"


      # Step 3: Checkout the target repository
      - name: Checkout target repository
        if: steps.find-sql-files.outputs.files != ''
        uses: actions/checkout@v3
        with:
          repository: nadib-klf/database-migration
          path: target-repo
          token: ${{ secrets.TARGET_REPO_TOKEN }}  # Use the default GitHub token or a personal access token

      # Step 4: Determine the latest version in the target repository
      - name: Find latest version in target repository
        if: steps.find-sql-files.outputs.files != ''
        id: find-latest-version
        run: |
          echo "Finding the latest version in the target repository"
          cd target-repo/resources/sql/
          LATEST_VERSION=$(ls V*__*.sql 2>/dev/null | grep -oP '^V\K\d+' | sort -n | tail -1 || echo "0")
          echo "Latest version found: ${LATEST_VERSION}"
          echo "::set-output name=latest_version::${LATEST_VERSION}"

      # Step 5: Increment the version and rename the new file
      - name: Increment version and rename file
        if: steps.find-sql-files.outputs.files != ''
        run: |
          echo "Incrementing version and renaming file"
          NEW_VERSION=$(( ${{ steps.find-latest-version.outputs.latest_version }} + 1 ))
          for FILE in ${{ steps.find-sql-files.outputs.files }}; do
            BASENAME=$(basename "$FILE")
            NEW_NAME="V${NEW_VERSION}__${BASENAME}"
            echo "Renaming $FILE to $NEW_NAME"
            cp "$FILE" "target-repo/resources/sql/$NEW_NAME"
          done

      # Step 6: Commit and push changes to the target repository
      - name: Commit and push changes to target repository
        if: steps.find-sql-files.outputs.files != ''
        run: |
          echo "Committing and pushing changes to target repository"
          cd target-repo
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add resources/sql/
          git commit -m "Sync new SQL file with version increment"
          git push
